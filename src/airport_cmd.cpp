/*
 * This file is part of OpenTTD.
 * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
 * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
 */

/** @file airport_cmd.cpp Handling of airport commands. */

#include "station_map.h"
#include "stdafx.h"
#include "command_func.h"
#include "core/backup_type.hpp"
#include "air.h"
#include "air_map.h"
#include "aircraft.h"
#include "airport_cmd.h"
#include "animated_tile_func.h"
#include "autoslope.h"
#include "bitmap_type.h"
#include "company_base.h"
#include "company_gui.h"
#include "depot_base.h"
#include "industry.h"
#include "landscape.h"
#include "landscape_cmd.h"
#include "newgrf_debug.h"
#include "newgrf_airport.h"
#include "newgrf_airporttiles.h"
#include "order_backup.h"
#include "pathfinder/yapf/yapf_cache.h"
#include "sound_func.h"
#include "station_func.h"
#include "station_kdtree.h"
#include "strings_func.h"
#include "town.h"
#include "vehicle_func.h"
#include "viewport_func.h"
#include "water.h"
#include "window_func.h"

#include "table/airporttile_ids.h"
#include "table/airport_defaults.h"
#include "table/airtypes.h"
#include "table/strings.h"
#include "table/track_land.h"

#include "widgets/station_widget.h"

/**
 * Updates the status of the Aircraft heading or in the airport
 * @param st Updated airport
 */
void UpdateAircraftOnUpdatedAirport(const Station *st)
{
	for (Aircraft *v : Aircraft::Iterate()) {
		if (!v->IsPrimaryVehicle()) continue;
		if (v->state == AS_FLYING || v->state == AS_FLYING_NO_DEST) {
			AircraftUpdateNextAirportPosAndOrder(v);
			continue;
		}

		switch (v->current_order.GetType()) {
			case OT_GOTO_STATION:
				if (v->current_order.GetDestination() != st->index) continue;
				v->dest_tile = v->GetOrderStationLocation(st->index);
				break;

			case OT_GOTO_DEPOT:
				if (!st->airport.HasHangar()) continue;
				if (v->current_order.GetDestination() != st->airport.hangar->index) continue;
				v->dest_tile = v->GetOrderHangarLocation(st->airport.hangar->index);
				break;

			default:
				break;
		}
	}

	SetWindowClassesDirty(WC_VEHICLE_ORDERS);
}

extern CommandCost CheckBuildableTile(TileIndex tile, uint invalid_dirs, int &allowed_z, bool allow_steep, bool check_bridge = true);

extern CommandCost FindJoiningAirport(StationID existing_station, StationID station_to_join, bool adjacent, TileArea ta, Station **st);

extern CommandCost BuildStationPart(Station **st, DoCommandFlag flags, bool reuse, TileArea area, StationNaming name_class);

/**
 * Calculate the noise level an airport would have if it were of a given airtype.
 * @param airport The airport
 * @param airtype The airtype to check, or INVALID_AIRTYPE (when INVALID_AIRTYPE is
 *                given, it will use the current airtype of the airport).
 * @return The total noise generated by the airport if it has the given airtype.
 */
uint8_t CalculateAirportNoiseLevel(const Airport airport, AirType airtype = INVALID_AIRTYPE)
{

	if (!IsValidTile(airport.tile)) return 0;

	if (airport.heliports.size() == 1 && IsBuiltInHeliportTile(airport.heliports[0])) return 0;

	if (airtype == INVALID_AIRTYPE) airtype = airport.air_type;

	const AirTypeInfo *air_type_info = GetAirTypeInfo(airtype);

	return (uint8_t)(air_type_info->base_noise_level +
			airport.runways.size() * air_type_info->runway_noise_level +
			airport.helipads.size() +
			airport.heliports.size() +
			airport.aprons.size());
}

/**
 * Get a possible noise reduction factor based on distance from town center.
 * The further you get, the less noise you generate.
 * So all those folks at city council can now happily slee...  work in their offices
 * @param noise_level noise level of the airport
 * @param distance minimum distance between town and airport
 * @return the noise that will be generated, according to distance
 */
uint8_t GetAirportNoiseLevelForDistance(uint noise_level, uint distance)
{
	/* 0 cannot be accounted, and 1 is the lowest that can be reduced from town.
	 * So no need to go any further*/
	if (noise_level < 2) return noise_level;

	/* The steps for measuring noise reduction are based on the "magical" (and arbitrary) 8 base distance
	 * adding the town_council_tolerance 4 times, as a way to graduate, depending of the tolerance.
	 * Basically, it says that the less tolerant a town is, the bigger the distance before
	 * an actual decrease can be granted */
	uint8_t town_tolerance_distance = 8 + (_settings_game.difficulty.town_council_tolerance * 4);

	/* now, we want to have the distance segmented using the distance judged bareable by town
	 * This will give us the coefficient of reduction the distance provides. */
	uint noise_reduction = distance / town_tolerance_distance;

	/* If the noise reduction equals the airport noise itself, don't give it for free.
	 * Otherwise, simply reduce the airport's level. */
	return noise_reduction >= noise_level ? 1 : noise_level - noise_reduction;
}

extern uint RotatedAirportSpecPosition(const TileIndex tile, const TileArea tile_area, const DiagDirection rotation);

CommandCost AddAirportTileTableToBitmapTileArea(const AirportTileLayout &atl, BitmapTileArea *bta, DiagDirection rotation, uint cost_multiplier)
{
	CommandCost cost(EXPENSES_CONSTRUCTION);

	uint tile_count = 0;
	for (TileIndex t : (TileArea)*bta) {
		uint pos = RotatedAirportSpecPosition(t, *bta, rotation);
		if (atl.tiles[pos].type != ATT_INVALID) {
			bta->SetTile(t);
			++tile_count;
		}
	}
	cost.AddCost(_price[PR_BUILD_STATION_AIRPORT] * tile_count * cost_multiplier);
	return cost;
}

/**
 * Finds the town nearest to given airport. Based on minimal manhattan distance to any airport's tile.
 * If two towns have the same distance, town with lower index is returned.
 * @param bta BitmapTileArea of the tiles of the airport
 * @param[out] mindist Minimum distance to town
 * @return nearest town to airport
 */
Town *AirportGetNearestTown(BitmapTileArea bta, uint &mindist)
{
	assert(Town::GetNumItems() > 0);

	Town *nearest = nullptr;
	mindist = UINT_MAX - 1; // prevent overflow

	for (TileIndex tile : bta) {
		if (!bta.HasTile(tile)) continue;
		/* Iterate over all tiles of the airport, as airport may not be rectangular. */
		Town *t = CalcClosestTownFromTile(tile, mindist + 1);
		if (t == nullptr) continue;

		uint dist = DistanceManhattan(t->xy, tile);
		if (dist == mindist && t->index < nearest->index) nearest = t;
		if (dist < mindist) {
			nearest = t;
			mindist = dist;
		}
	}

	return nearest;
}


/** Recalculate the noise generated by the airports of each town */
void UpdateAirportsNoise()
{
	for (Town *t : Town::Iterate()) t->noise_reached = 0;

	for (const Station *st : Station::Iterate()) {
		if (st->airport.tile != INVALID_TILE && st->airport.type != AT_OILRIG) {
			uint8_t noise_level = CalculateAirportNoiseLevel(st->airport);
			uint dist;
			BitmapTileArea bta;
			bta.Initialize(st->airport);
			for (TileIndex t : st->airport) {
				if (st->TileBelongsToAirport(t)) bta.SetTile(t);
			}

			Town *nearest = AirportGetNearestTown(bta, dist);
			nearest->noise_reached += GetAirportNoiseLevelForDistance(noise_level, dist);
		}
	}
}

void GetAirportArea(const Station *st, const BitmapTileArea new_tiles, BitmapTileArea &all_tiles)
{
	TileArea complete_tilearea;
	if (st != nullptr) {
		for (TileIndex t : st->airport) if (st->TileBelongsToAirport(t)) complete_tilearea.Add(t);
	}
	for (TileIndex t : new_tiles) complete_tilearea.Add(t);
	all_tiles.Initialize(complete_tilearea);
	for (TileIndex t : new_tiles) all_tiles.SetTile(t);
	if (st != nullptr) {
		for (TileIndex t : st->airport) if (st->TileBelongsToAirport(t)) all_tiles.SetTile(t);
	}
}

/**
 * Checks noise and whether there are too many airports in a town.
 * @param st Station with preexisting airport
 * @param added_area BitmapTileArea containing the tiles of the airport to be added.
 * @param[out] pre_town The town closest to preexisting airport.
 * @param[out] post_town The town closest to modified airport.
 * @param[out] pre_noise The current noise that the airport of station \b st in \b pre_town
 * @param[in,out] post_noise The addition of noise of the new tiles as in, the noise the airport generates for post_town as out.
 * @return Whether it is possible to add the tiles due to noise restriction or limit of airports.
 */
CommandCost CheckTownAuthorityForAirports(TileIndex tile, Station *st, const BitmapTileArea added_area, Town **pre_town, Town **post_town, uint &pre_noise, uint &post_noise)
{
	/* Get the area containing previous airport tiles from station st and new added tiles. */
	BitmapTileArea modified_area, initial_area;
	GetAirportArea(st, BitmapTileArea(), initial_area);
	GetAirportArea(st, added_area, modified_area);

	/* Get the closest town of the preexisting airport to be joined to and the closest town for the modified airport. */
	uint pre_dist = 0;
	uint post_dist = 0;
	*pre_town = (st != nullptr && (st->facilities & FACIL_AIRPORT) != FACIL_NONE) ? AirportGetNearestTown(initial_area, pre_dist) : nullptr;
	*post_town = AirportGetNearestTown(modified_area, post_dist);

	/* Get the current noise for preexisting airport and the noise for the modified airport. */
	pre_noise = *pre_town != nullptr ? CalculateAirportNoiseLevel(st->airport) : 0;
	post_noise = GetAirportNoiseLevelForDistance(post_noise + pre_noise, post_dist);
	pre_noise = GetAirportNoiseLevelForDistance(pre_noise, pre_dist);

	/* Check if local auth would allow a new airport */
	StringID authority_refuse_message = STR_NULL;
	Town *authority_refuse_town = *post_town;

	if (_settings_game.economy.station_noise_level) {
		/* Do not allow to build a new airport if this raises the town noise over the maximum allowed by town. */
		if (*post_town == *pre_town) {
			/* Preexisting airport and the same town to get noise... */
			if ((*post_town)->noise_reached - pre_noise + post_noise > (*post_town)->MaxTownNoise()) {
				authority_refuse_message = STR_ERROR_LOCAL_AUTHORITY_REFUSES_NOISE;
			}
		} else {
			/* Check that adding the airport noise to post_town doesn't exceed the maximum allowed by town. */
			if (((*post_town)->noise_reached + post_noise) > (*post_town)->MaxTownNoise()) {
				authority_refuse_message = STR_ERROR_LOCAL_AUTHORITY_REFUSES_NOISE;
			}
		}
	} else if (_settings_game.difficulty.town_council_tolerance != TOWN_COUNCIL_PERMISSIVE) {
		if (st != nullptr && (st->facilities & FACIL_AIRPORT) != FACIL_NONE) return CommandCost();
		authority_refuse_town = ClosestTownFromTile(tile, UINT_MAX);
		uint num = 0;
		for (const Station *s : Station::Iterate()) {
			if (s->town == authority_refuse_town && (s->facilities & FACIL_AIRPORT) && s->airport.type != AT_OILRIG) num++;
		}
		if (num >= 2) {
			authority_refuse_message = STR_ERROR_LOCAL_AUTHORITY_REFUSES_AIRPORT;
		}
	}

	if (authority_refuse_message != STR_NULL) {
		SetDParam(0, authority_refuse_town->index);
		return_cmd_error(authority_refuse_message);
	}

	return CommandCost();
}

void UpdateNoiseForTowns(Town *pre_nearest, Town *post_nearest, const uint pre_noise, const uint post_noise)
{
	/* Subtract previous noise. */
	if (pre_noise > 0) pre_nearest->noise_reached -= pre_noise;

	/* Add noise to updated airport. */
	post_nearest->noise_reached += post_noise;

	if (_settings_game.economy.station_noise_level) {
		SetWindowDirty(WC_TOWN_VIEW, post_nearest->index);
		if (pre_nearest != nullptr && pre_nearest != post_nearest) SetWindowDirty(WC_TOWN_VIEW, pre_nearest->index);
	}
}

CommandCost inline CheckSettingBuildByTile()
{
	if (!_settings_game.station.allow_modify_airports) return_cmd_error(STR_ERROR_AIRPORT_DISABLED_BY_TILE);
	return CommandCost();
}

extern CommandCost ValidateAutoDrag(Trackdir *trackdir, TileIndex start, TileIndex end);

/**
 * Checks if there is a vehicle in an airport given by one of its tiles.
 * @param st Station to check.
 * @return A command cost with an error if a vehicle is found on ground or in a runway.
 */
CommandCost AircraftInAirport(const Station *st)
{
	if (st == nullptr) return CommandCost();

	for (TileIndex tile : st->airport) {
		if (!st->TileBelongsToAirport(tile)) continue;

		if ((MayHaveAirTracks(tile) && HasAirportTrackReserved(tile)) ||
			(IsRunway(tile) && GetReservationAsRunway(tile)))
			return_cmd_error(STR_ERROR_AIRPORT_PRESENT_AIRCRAFT);

		/* Aircraft can be hidden inside depots with no associated reservation. */
		if (IsStandardHangarTile(tile)) {
			CommandCost ret = EnsureFreeHangar(tile);
			if (ret.Failed()) return ret;
		}
	}

	return CommandCost();
}

CommandCost CheckRunwayLength(AirType air_type, uint length)
{
	if (GetAirTypeInfo(air_type)->min_runway_length > length) return_cmd_error(STR_ERROR_AIRPORT_RUNWAY_TOO_SHORT);
	return CommandCost();
}

CommandCost AddAirportTrack(TileIndex tile, Track track, DoCommandFlag flags)
{
	assert(IsAirportTile(tile) && !IsHangar(tile));

	if (!IsValidTile(tile)) return CMD_ERROR;
	CommandCost ret = CheckTileOwnership(tile);
	if (ret.Failed()) return ret;
	if (!MayHaveAirTracks(tile)) return_cmd_error(STR_ERROR_AIRPORT_CAN_T_HAVE_TRACKS);
	if (HasAirportTileTrack(tile, track)) return_cmd_error(STR_ERROR_ALREADY_BUILT);
	AirportTileType att = GetAirportTileType(tile);
	if ((att == ATT_HANGAR_STANDARD || att == ATT_HANGAR_EXTENDED) && !IsDiagonalTrack(track)) return_cmd_error(STR_ERROR_AIRPORT_CAN_T_ADD_TRACK_HANGAR);

	if (!HasTrack(GetAllowedTracks(tile), track)) return_cmd_error(STR_ERROR_AIRPORT_NO_COMPATIBLE_NEIGHBOURS);

	if (flags & DC_EXEC) {
		SetAirportTileTracks(tile, GetAirportTileTracks(tile) | TrackToTrackBits(track));
		if (_show_airport_tracks) MarkTileDirtyByTile(tile);
	}

	return CommandCost();
}

CommandCost RemoveAirportTrack(TileIndex tile, Track track, DoCommandFlag flags)
{
	assert(IsAirportTile(tile) && !IsHangar(tile));

	if (!IsValidTile(tile)) return CMD_ERROR;
	CommandCost ret = CheckTileOwnership(tile);
	if (ret.Failed()) return ret;

	if (!MayHaveAirTracks(tile) || !HasAirportTileTrack(tile, track)) return CommandCost();

	if (HasAirportTrackReserved(tile, track) || (IsRunwayExtreme(tile) && GetReservationAsRunway(tile))) return CMD_ERROR;

	if (flags & DC_EXEC) {
		SetAirportTileTracks(tile, GetAirportTileTracks(tile) & ~TrackToTrackBits(track));
		if (_show_airport_tracks) MarkTileDirtyByTile(tile);
	}

	return CommandCost();
}

static const TileIndexDiffC _trackdelta[] = {
	{ -1,  0 }, {  0,  1 }, { -1,  0 }, {  0,  1 }, {  1,  0 }, {  0,  1 },
	{  0,  0 },
	{  0,  0 },
	{  1,  0 }, {  0, -1 }, {  0, -1 }, {  1,  0 }, {  0, -1 }, { -1,  0 },
	{  0,  0 },
	{  0,  0 }
};

/**
 * Add/Remove tracks for an airport.
 * @param flags operation to perform
 * @param start_tile start tile of drag
 * @param end_tile end tile of drag
 * @param air_type Air type (gravel, asphalt, water...)
 * @param add whether to add or remove tracks
 * @param track starting track
 * @return the cost of this operation or an error
 */
CommandCost CmdAddRemoveTracksToAirport(DoCommandFlag flags, TileIndex start_tile, TileIndex end_tile, AirType air_type, bool add, Track track)
{
	Trackdir trackdir = TrackToTrackdir(track);

	CommandCost ret = ValidateAutoDrag(&trackdir, start_tile, end_tile);
	if (ret.Failed()) return ret;

	if ((flags & DC_EXEC) && _settings_client.sound.confirm) SndPlayTileFx(SND_1F_CONSTRUCTION_OTHER, start_tile);

	bool had_success = false;
	std::vector<Station *> affected_stations;
	CommandCost last_error = CMD_ERROR;
	CommandCost total_cost;
	TileIndex tile = start_tile;
	for (;;) {
		if (!IsValidTile(tile) || !IsAirportTile(tile) || !MayHaveAirTracks(tile) || IsHangar(tile) || (IsApron(tile) && IsHeliport(tile)))
			goto fill_next_track;

		if (air_type != GetAirType(tile)) {
			ret.MakeError(STR_ERROR_AIRPORT_INVALID_AIR_TYPE);
		} else {
			assert(IsValidTrackdir(trackdir));
			if (add) {
				ret = AddAirportTrack(tile, TrackdirToTrack(trackdir), flags);
			} else {
				ret = RemoveAirportTrack(tile, TrackdirToTrack(trackdir), flags);
			}
		}

		if (ret.Failed()) {
			last_error = ret;
			if (last_error.GetErrorMessage() != STR_ERROR_ALREADY_BUILT) {
				return last_error;
			}

			/* Ownership errors are more important. */
			if (last_error.GetErrorMessage() == STR_ERROR_OWNED_BY) break;
		} else {
			had_success = true;
			affected_stations.emplace_back(Station::GetByTile(tile));
			total_cost.AddCost(ret);
		}

		fill_next_track:
		if (tile == end_tile) break; // end tile

		tile += ToTileIndexDiff(_trackdelta[trackdir]);

		/* toggle railbit for the non-diagonal tracks. */
		if (!IsDiagonalTrackdir(trackdir)) ToggleBit(trackdir, 0);
	}

	if (flags & DC_EXEC) {
		/* Do all station specific functions here. */
		for (Station *st : affected_stations) {
			assert(st != nullptr);
			st->UpdateAirportDataStructure();
			UpdateAircraftOnUpdatedAirport(st);
		}
	}

	if (had_success) return total_cost;

	return last_error;
}

/**
 * Define/undefine a runway.
 * @param flags operation to perform
 * @param start_tile start tile of drag
 * @param end_tile end tile of drag
 * @param air_type air type to deal with
 * @param runway_type type of runway start (allow/don' allow landing)
 * @return the cost of this operation or an error
 */
CommandCost AddRunway(DoCommandFlag flags, TileIndex start_tile, TileIndex end_tile, AirType air_type, AirportTileType runway_type)
{
	assert(IsValidTile(start_tile));
	assert(IsAirportTile(start_tile));

	if (!ValParamAirType(air_type)) return_cmd_error(STR_ERROR_AIRPORT_INCORRECT_AIRTYPE);

	if (air_type != GetAirType(start_tile)) return_cmd_error(STR_ERROR_AIRPORT_INVALID_AIR_TYPE);

	Station *st = Station::GetByTile(start_tile);
	assert(st != nullptr);

	if (st->airport.runways.size() + 1 > GetAirTypeInfo(air_type)->max_num_runways) return_cmd_error(STR_ERROR_AIRPORT_TOO_MUCH_RUNWAYS);

	Town *pre_town = nullptr;
	Town *post_town = nullptr;
	uint pre_noise;
	uint post_noise = GetAirTypeInfo(air_type)->runway_noise_level;
	CommandCost ret = CheckTownAuthorityForAirports(start_tile, st, BitmapTileArea(), &pre_town, &post_town, pre_noise, post_noise);
	if (ret.Failed()) return ret;

	TileArea ta(start_tile, end_tile);
	assert(ta.h == 1 || ta.w == 1); // Diagonal area. //
	uint8_t length = ta.h * ta.w;
	ret = CheckRunwayLength(air_type, length);
	if (ret.Failed()) return ret;

	DiagDirection dir = DiagdirBetweenTiles(start_tile, end_tile);
	Direction adding_dir = DiagDirToDir(dir);

	for (TileIndex tile_iter : ta) {
		if (!IsAirportTile(tile_iter)) return_cmd_error(STR_ERROR_AIRPORT_RUNWAY_INCOMPLETE);
		if (GetStationIndex(tile_iter) != st->index) return_cmd_error(STR_ERROR_AIRPORT_RUNWAY_INCOMPLETE);
		if (!IsSimpleTrack(tile_iter) && !IsPlainRunway(tile_iter)) return_cmd_error(STR_ERROR_AIRPORT_RUNWAY_CAN_T_BUILD_OVER);
		if (IsPlainRunway(tile_iter)) {
			/* Cannot build an extreme runway tile on an already existing runway. */
			if (tile_iter == start_tile || tile_iter == end_tile) return_cmd_error(STR_ERROR_AIRPORT_RUNWAY_OVERLAP);

			/* Some directions are not compatible.
			 * There is no need to do this check.
			 * Anyway, it will be checked. */
			Direction cur_dir = GetPlainRunwayDirections(tile_iter);
			if (!IsDiagonalDirection(cur_dir) ||
				(cur_dir != ((adding_dir + 2) % DIR_END) && (cur_dir + 2) % DIR_END != adding_dir))
				return_cmd_error(STR_ERROR_AIRPORT_RUNWAY_CAN_T_BUILD_OVER);
		}
	}

	CommandCost cost(EXPENSES_CONSTRUCTION);
	cost.AddCost(_price[PR_BUILD_STATION_AIRPORT] * length * GetAirTypeInfo(air_type)->cost_multiplier);

	if (flags & DC_EXEC) {
		/* Always update the noise, so there will be no need to recalculate when option toggles. */
		UpdateNoiseForTowns(pre_town, post_town, pre_noise, post_noise);

		for (TileIndex tile_iter : ta) {
			TrackBits prev_tracks = MayHaveAirTracks(tile_iter) ? GetAirportTileTracks(tile_iter) : TRACK_BIT_NONE;
			TrackBits reserved_tracks = prev_tracks != TRACK_BIT_NONE ? GetReservedAirportTracks(tile_iter) : TRACK_BIT_NONE;
			bool reserved_runway = IsRunway(tile_iter) && GetReservationAsRunway(tile_iter);
			if ((tile_iter == start_tile) || (tile_iter == end_tile)) {
				assert(!IsRunway(tile_iter));
				Tile(tile_iter).m8() = 0;
				AirportTileType att = start_tile == tile_iter ? runway_type : ATT_RUNWAY_END;
				SetAirportTileType(tile_iter, att);
				SetRunwayExtremeDirection(tile_iter, dir);
			} else {
				if (IsPlainRunway(tile_iter)) {
					[[maybe_unused]] Direction cur_dir = GetPlainRunwayDirections(tile_iter);
					assert(IsDiagonalDirection(cur_dir));
					assert(cur_dir == ((adding_dir + 2) % DIR_END) || (cur_dir + 2) % DIR_END == adding_dir);
					AddPlainRunwayDirections(tile_iter, dir, false);
				} else {
					SetAirportTileType(tile_iter, ATT_RUNWAY_MIDDLE);
					Tile(tile_iter).m8() = 0;
					AddPlainRunwayDirections(tile_iter, dir, true);
				}
			}
			SetAirportTileTracks(tile_iter, prev_tracks);
			SetAirportTracksReservation(tile_iter, reserved_tracks);
			SetReservationAsRunway(tile_iter, reserved_runway);
		}

		st->UpdateAirportDataStructure();
		UpdateAircraftOnUpdatedAirport(st);
	}

	return cost;
}

/**
 * Get the tiles of a runway.
 * @param tile An extreme tile of a runway.
 * @return the tile area of the runway.
 */
TileArea GetRunwayTileArea(TileIndex tile)
{
	assert(IsRunwayExtreme(tile));
	DiagDirection dir = GetRunwayExtremeDirection(tile);
	return TileArea(GetRunwayExtreme(tile, dir), GetRunwayExtreme(tile, ReverseDiagDir(dir)));
}

/**
 * Define/undefine a apron.
 * @param flags operation to perform
 * @param start_tile start tile of drag
 * @param end_tile end tile of drag
 * @return the cost of this operation or an error
 */
CommandCost RemoveRunway(DoCommandFlag flags, TileIndex start_tile, TileIndex end_tile)
{
	if (start_tile == end_tile || !IsRunwayExtreme(start_tile) || !IsRunwayExtreme(end_tile)) return_cmd_error(STR_ERROR_AIRPORT_RUNWAY_CAN_T_REMOVE);

	assert(GetRunwayTileArea(start_tile).Contains(end_tile) && IsRunwayExtreme(start_tile) && IsRunwayExtreme(end_tile));

	TileArea ta(start_tile, end_tile);
	assert(ta.w == 1 || ta.h == 1);
	const AirTypeInfo *ati = GetAirTypeInfo(GetAirType(start_tile));
	CommandCost cost(EXPENSES_CONSTRUCTION);
	cost.AddCost(_price[PR_CLEAR_STATION_AIRPORT] * ta.w * ta.h * ati->cost_multiplier);

	Station *st = Station::GetByTile(start_tile);
	assert(st != nullptr);

	for (TileIndex tile_iter : ta) {
		assert(IsRunway(tile_iter));
		if (GetReservationAsRunway(tile_iter)) return CMD_ERROR;
	}

	if (flags & DC_EXEC) {
		uint dist;
		BitmapTileArea bta;
		bta.Initialize(st->airport);
		for (TileIndex t : st->airport) {
			if (st->TileBelongsToAirport(t)) bta.SetTile(t);
		}
		Town *nearest = AirportGetNearestTown(bta, dist);
		uint8_t noise_level = CalculateAirportNoiseLevel(st->airport);
		nearest->noise_reached -= GetAirportNoiseLevelForDistance(noise_level, dist);

		DiagDirection diag_dir = GetRunwayExtremeDirection(start_tile);
		for (Tile tile_iter : ta) {
			assert(IsRunway(tile_iter));
			if (IsPlainRunway(tile_iter) && !IsDiagonalDirection(GetPlainRunwayDirections(tile_iter))) {
				RemovePlainRunwayDirections(tile_iter, diag_dir);
			} else {
				SetAirportTileType(tile_iter, ATT_SIMPLE_TRACK);
				SB(tile_iter.m8(), 12, 4, 0);
				SetAirGfxType(tile_iter, true);
			}
			MarkTileDirtyByTile(tile_iter);
		}

		st->UpdateAirportDataStructure();

		noise_level = CalculateAirportNoiseLevel(st->airport);
		nearest->noise_reached += GetAirportNoiseLevelForDistance(noise_level, dist);
		if (_settings_game.economy.station_noise_level) {
			SetWindowDirty(WC_TOWN_VIEW, nearest->index);
		}

		UpdateAircraftOnUpdatedAirport(st);
	}

	return cost;
}

/**
 * When modifying an airport tile, neighbour tiles may lose some tracks.
 * Return true if any affected neighbour tile is reserved.
 * @param tile Tile to check.
 * @pre IsAirportTile
 */
bool HasReservationsOnNeighbourTiles(TileIndex tile)
{
	assert(IsAirportTile(tile));

	StationID station_id = GetStationIndex(tile);

	for (Direction dir = DIR_BEGIN; dir < DIR_END; dir++) {
		TileIndex neighbour =  TileAddByDir(tile, dir);
		if (!IsValidTile(neighbour)) continue;
		if (!IsAirportTileOfStation(neighbour, station_id)) continue;
		if (!MayHaveAirTracks(neighbour)) continue;

		TrackBits reserved = GetReservedAirportTracks(neighbour);
		switch (dir) {
			case DIR_N:
				reserved &= TRACK_BIT_LOWER;
				break;
			case DIR_NE:
				reserved &= (TRACK_BIT_LOWER | TRACK_BIT_LEFT);
				break;
			case DIR_E:
				reserved &= TRACK_BIT_LEFT;
				break;
			case DIR_SE:
				reserved &= (TRACK_BIT_LEFT | TRACK_BIT_UPPER);
				break;
			case DIR_S:
				reserved &= TRACK_BIT_UPPER;
				break;
			case DIR_SW:
				reserved &= (TRACK_BIT_UPPER | TRACK_BIT_RIGHT);
				break;
			case DIR_W:
				reserved &= TRACK_BIT_RIGHT;
				break;
			case DIR_NW:
				reserved &= (TRACK_BIT_RIGHT | TRACK_BIT_LOWER);
				break;

			default: NOT_REACHED();
		}

		if (reserved != TRACK_BIT_NONE) return true;
	}

	return false;
}

/**
 * Change the airtype graphics of an airport tile.
 * @param tile
 * @param at New airtype tile.
 */
void SetGfxByAirtypeTile(TileIndex tile, AirportTiles at) {
	DeleteAnimatedTile(tile);
	SetAirGfxType(tile, true);
	SetTileAirportGfx(tile, at);
	if (AirportTileSpec::GetByTile(tile)->animation.status != ANIM_STATUS_NO_ANIMATION) AddAnimatedTile(tile);
}

/**
 * Redefine use of airport tiles.
 * @param flags operation to perform
 * @param start_tile start tile of drag
 * @param end_tile end tile of drag
 * @param air_type air type to build or to remove
 * @param air_tile_type (hangar, helipad...)
 * @param infra_type infrastrucutre type (building 1, building 2...)
 * @param direction heliport/infrastructure direction or hangar exit direction
 * @param adding whether adding or removing tiles
 * @param diagonal whether remove/add a diagonal tile area
 * @return the cost of this operation or an error
 */
CommandCost CmdChangeAirportTiles(DoCommandFlag flags, TileIndex start_tile, TileIndex end_tile, AirType air_type, AirportTileType air_tile_type, AirportTiles infra_type, DiagDirection direction, bool adding, bool diagonal)
{
	if (!IsAirportTile(start_tile)) return CMD_ERROR;
	bool adds_noise = false;
	const AirTypeInfo *ati = GetAirTypeInfo(air_type);

	switch (air_tile_type) {
		case ATT_APRON_NORMAL:
		case ATT_APRON_HELIPAD:
		case ATT_APRON_HELIPORT:
			adds_noise = adding;
			break;
		case ATT_HANGAR_STANDARD:
		case ATT_HANGAR_EXTENDED:
			if (adding && Company::IsValidHumanID(_current_company) &&
					!HasBit(_settings_game.depot.hangar_types, air_tile_type == ATT_HANGAR_EXTENDED)) {
				return_cmd_error(STR_ERROR_DEPOT_TYPE_NOT_AVAILABLE);
			}
			break;
		case ATT_INFRASTRUCTURE_WITH_CATCH:
		case ATT_INFRASTRUCTURE_NO_CATCH:
		case ATT_RUNWAY_START_ALLOW_LANDING:
		case ATT_RUNWAY_START_NO_LANDING:
			break;
		case ATT_SIMPLE_TRACK:
		case ATT_RUNWAY_MIDDLE:
		case ATT_RUNWAY_END:
		case ATT_APRON_BUILTIN_HELIPORT:
		default:
			/* Not handled in this command. */
			NOT_REACHED();
		case ATT_WAITING_POINT:
			/* Not implemented. */
			NOT_REACHED();
	}

	CommandCost ret = CheckSettingBuildByTile();
	if (ret.Failed()) return ret;

	if (!ValParamAirType(air_type)) return_cmd_error(STR_ERROR_AIRPORT_INCORRECT_AIRTYPE);

	TileArea ta(start_tile, end_tile);

	if (air_tile_type == ATT_RUNWAY_START_ALLOW_LANDING || air_tile_type == ATT_RUNWAY_START_NO_LANDING) {
		if (air_type != GetAirType(start_tile)) return_cmd_error(STR_ERROR_AIRPORT_INVALID_AIR_TYPE);
		if (GetTileOwner(start_tile) != _current_company) return_cmd_error(STR_ERROR_AREA_IS_OWNED_BY_ANOTHER);

		if (adding) {
			/* check same station and free */
			return AddRunway(flags, start_tile, end_tile, air_type, air_tile_type);
		} else {
			return RemoveRunway(flags, start_tile, end_tile);
		}
	}

	CommandCost cost(EXPENSES_CONSTRUCTION);

	std::unique_ptr<TileIterator> iter;
	if (diagonal) {
		iter = std::make_unique<DiagonalTileIterator>(start_tile, end_tile);
	} else {
		iter = std::make_unique<OrthogonalTileIterator>(start_tile, end_tile);
	}

	Station *st = nullptr;
	Town *nearest = nullptr;
	uint dist = 0;
	uint noise_increase = 0;
	for (; *iter != INVALID_TILE; ++(*iter)) {
		Tile tile_iter = Tile(*iter);
		if (!IsAirportTile(tile_iter)) return CMD_ERROR;
		if (GetTileOwner(tile_iter) != _current_company) return CMD_ERROR;
		if (air_type != GetAirType(tile_iter)) continue;

		if (IsStandardHangarTile(tile_iter)) {
			CommandCost ret = EnsureFreeHangar(tile_iter);
			if (ret.Failed()) return ret;
		}

		if (st == nullptr) {
			st = Station::GetByTile(tile_iter);

			BitmapTileArea bta;
			bta.Initialize(st->airport);
			for (TileIndex t : st->airport) {
				if (st->TileBelongsToAirport(t)) bta.SetTile(t);
			}
			nearest = AirportGetNearestTown(bta, dist);
			if (flags & DC_EXEC) {
				uint8_t noise_level = CalculateAirportNoiseLevel(st->airport);
				nearest->noise_reached -= GetAirportNoiseLevelForDistance(noise_level, dist);
			}
		} else {
			if (st->index != GetStationIndex(tile_iter)) return CMD_ERROR;
		}

		TrackBits tracks = MayHaveAirTracks(tile_iter) ? GetAirportTileTracks(tile_iter) : TRACK_BIT_NONE;
		TrackBits reserved_tracks = tracks != TRACK_BIT_NONE ? GetReservedAirportTracks(tile_iter) : TRACK_BIT_NONE;
		bool close_tracks = adding && HasReservationsOnNeighbourTiles(tile_iter);

		if (adding) {
			if (!IsSimpleTrack(tile_iter)) continue;
			if (air_tile_type == ATT_APRON_HELIPORT &&
				!AreHeliportsAvailable(air_type)) return_cmd_error(STR_ERROR_AIRPORT_CAN_T_BUILD_HELIPORT);
			if (GetAirportTileType(tile_iter) == air_tile_type) continue;

			cost.AddCost(_price[PR_BUILD_STATION_AIRPORT] * ati->cost_multiplier);
			if (adds_noise && !IsApron(tile_iter)) {
				/* Noise concerns... */
				noise_increase++;
			}

			switch (air_tile_type) {
				case ATT_INFRASTRUCTURE_WITH_CATCH:
				case ATT_INFRASTRUCTURE_NO_CATCH:
				case ATT_HANGAR_STANDARD:
				case ATT_HANGAR_EXTENDED:
				case ATT_APRON_HELIPORT:
					if (close_tracks || reserved_tracks != TRACK_BIT_NONE) return_cmd_error(STR_ERROR_AIRPORT_PRESENT_AIRCRAFT);
					break;
				default:
					break;
			}

			if (flags & DC_EXEC) {
				switch (air_tile_type) {
					default: NOT_REACHED();
					case ATT_INFRASTRUCTURE_WITH_CATCH:
					case ATT_INFRASTRUCTURE_NO_CATCH: {
						SetAirportTileType(tile_iter, air_tile_type);
						tile_iter.m8() = 0;
						SetAirportTileRotation(tile_iter, direction);
						break;
					}
					case ATT_APRON_NORMAL:
					case ATT_APRON_HELIPAD:
					case ATT_APRON_HELIPORT:
						SetAirportTileType(tile_iter, air_tile_type);
						SetAirportTileRotation(tile_iter, direction);
						if (air_tile_type == ATT_APRON_HELIPORT) {
							SetAirportTileTracks(tile_iter, TRACK_BIT_CROSS);
						} else {
							SetAirportTileTracks(tile_iter, tracks);
							SetAirportTracksReservation(tile_iter, reserved_tracks);
						}
						break;
					case ATT_HANGAR_STANDARD:
					case ATT_HANGAR_EXTENDED:
						SetAirportTileType(tile_iter, air_tile_type);
						SetHangarDirection(tile_iter, direction);
						SetAirportTileTracks(tile_iter, HasBit(tile_iter.m8(), 14) ? TRACK_BIT_Y : TRACK_BIT_X);
						break;
				}
				SetGfxByAirtypeTile(tile_iter, infra_type);
				MarkTileDirtyByTile(tile_iter);
			}

		} else {
			/* Removing. */

			if (GetAirportTileType(tile_iter) != air_tile_type) continue;
			if (air_tile_type == ATT_HANGAR_STANDARD || air_tile_type == ATT_HANGAR_EXTENDED) {
				if (!IsHangar(tile_iter) || GetAirportTileType(tile_iter) != air_tile_type) continue;
			} else if (air_tile_type == ATT_INFRASTRUCTURE_WITH_CATCH || air_tile_type == ATT_INFRASTRUCTURE_NO_CATCH) {
				if (!IsInfrastructure(tile_iter) || GetAirportTileType(tile_iter) != air_tile_type) continue;
			}

			if ((reserved_tracks & TRACK_BIT_CROSS) != TRACK_BIT_NONE) return_cmd_error(STR_ERROR_AIRPORT_PRESENT_AIRCRAFT);

			cost.AddCost(_price[PR_CLEAR_STATION_AIRPORT] * ati->cost_multiplier);
			if (flags & DC_EXEC) {
				switch (air_tile_type) {
					default: NOT_REACHED();
					case ATT_INFRASTRUCTURE_WITH_CATCH:
					case ATT_INFRASTRUCTURE_NO_CATCH:
					case ATT_APRON_NORMAL:
					case ATT_APRON_HELIPAD:
					case ATT_APRON_HELIPORT:
					case ATT_HANGAR_STANDARD:
					case ATT_HANGAR_EXTENDED:
						tile_iter.m8() = 0;
						SetAirportTileType(tile_iter, ATT_SIMPLE_TRACK);
						SetAirGfxType(tile_iter, true);
						break;
				}
				SetAirportTileTracks(tile_iter, tracks);
				SetAirportTracksReservation(tile_iter, reserved_tracks);

				MarkTileDirtyByTile(tile_iter);
			}
		}
	}

	if (st == nullptr) return CMD_ERROR;

	if (flags & DC_EXEC) {
		st->UpdateAirportDataStructure();
		st->AfterStationTileSetChange(true, STATION_AIRPORT);

		uint8_t noise_level = CalculateAirportNoiseLevel(st->airport);
		assert(nearest != nullptr);
		nearest->noise_reached += GetAirportNoiseLevelForDistance(noise_level, dist);
		if (_settings_game.economy.station_noise_level) {
			SetWindowDirty(WC_TOWN_VIEW, nearest->index);
		}

		UpdateAircraftOnUpdatedAirport(st);

	} else if (noise_increase != 0) {
		/* Check noise limits. */
		Town *pre_town = nullptr;
		Town *post_town = nullptr;
		uint pre_noise;
		uint post_noise = noise_increase;
		ret = CheckTownAuthorityForAirports(start_tile, st, BitmapTileArea(), &pre_town, &post_town, pre_noise, post_noise);
		assert(pre_town == nearest);
		assert(post_town == nearest);
		if (ret.Failed()) return ret;
	}

	return cost;
}


/**
 * Change the air type of an airport.
 * @param flags operation to perform
 * @param tile with one tile of the airport
 * @param air_type new air type for the airport
 */
CommandCost CmdChangeAirType(DoCommandFlag flags, TileIndex tile, AirType air_type)
{
	if (!IsAirportTile(tile)) return_cmd_error(STR_ERROR_SITE_UNSUITABLE);
	if (!IsValidTile(tile)) return CMD_ERROR;

	CommandCost ret = CheckSettingBuildByTile();
	if (ret.Failed()) return ret;

	ret = CheckTileOwnership(tile);
	if (ret.Failed()) return ret;

	assert(Station::IsValidID(GetStationIndex(tile)));
	Station *st = Station::GetByTile(tile);
	assert(st != nullptr);

	/* Check air type. */
	if (!ValParamAirType(air_type)) return_cmd_error(STR_ERROR_AIRPORT_INCORRECT_AIRTYPE);
	if (st->airport.air_type == air_type) return_cmd_error(STR_ERROR_AIRPORT_ALREADY_AIRTYPE);
	if (st->airport.air_type == AIRTYPE_WATER) return_cmd_error(STR_ERROR_AIRPORT_CAN_T_CONVERT_TO_WATERED);
	if (air_type == AIRTYPE_WATER) return_cmd_error(STR_ERROR_AIRCRAFT_INCOMPATIBLE_AIR_TYPE);
	if (st->airport.runways.size() > GetAirTypeInfo(air_type)->max_num_runways) return_cmd_error(STR_ERROR_AIRPORT_TOO_MUCH_RUNWAYS);

	if (!AreHeliportsAvailable(air_type) && !st->airport.heliports.empty()) {
		return_cmd_error(STR_ERROR_AIRPORT_CAN_T_CONVERT_HELIPORT);
	}

	for (TileIndex t : st->airport.runways) {
		uint length = GetRunwayLength(t);
		ret = CheckRunwayLength(air_type, length);
		if (ret.Failed()) return ret;
	}

	ret = AircraftInAirport(st);
	if (ret.Failed()) return ret;

	Town *pre_town = nullptr;
	Town *post_town = nullptr;
	uint pre_noise;
	uint post_noise = CalculateAirportNoiseLevel(st->airport, air_type) - CalculateAirportNoiseLevel(st->airport);
	if (st != nullptr && (st->facilities & FACIL_AIRPORT) != FACIL_NONE) post_noise -= GetAirTypeInfo(st->airport.air_type)->base_noise_level;

	ret = CheckTownAuthorityForAirports(tile, st, BitmapTileArea(), &pre_town, &post_town, pre_noise, post_noise);
	if (ret.Failed()) return ret;
	assert(pre_town == post_town);

	uint tiles = 0;
	for (TileIndex tile_iter : st->airport) {
		if (!IsAirportTileOfStation(tile_iter, st->index)) continue;

		tiles++;
		if (flags & DC_EXEC) {
			SetAirType(tile_iter, air_type);
			MarkTileDirtyByTile(tile_iter);

			if (!HasAirtypeGfx(tile_iter)) {
				bool is_infrastructure = IsInfrastructure(tile_iter);
				AirportTiles at = is_infrastructure ? GetAirportGfxForAirtype(tile_iter) : ATTG_DEFAULT_GFX;
				SetGfxByAirtypeTile(tile_iter, at);
				if (is_infrastructure) SetAirportGfxForAirtype(tile_iter, ATTG_DEFAULT_GFX);
			}
		}
	}

	CommandCost cost(EXPENSES_CONSTRUCTION);
	cost.AddCost((_price[PR_CLEAR_STATION_AIRPORT] * GetAirTypeInfo(st->airport.air_type)->cost_multiplier +
	_price[PR_BUILD_STATION_AIRPORT] * GetAirTypeInfo(air_type)->cost_multiplier) * tiles);

	if (flags & DC_EXEC) {
		Company *c = Company::Get(st->owner);
		c->infrastructure.air[air_type] += tiles;
		c->infrastructure.air[st->airport.air_type] -= tiles;

		st->airport.air_type = air_type;
		st->UpdateAirportDataStructure();
		st->AfterStationTileSetChange(true, STATION_AIRPORT);
		if (st->airport.HasHangar()) InvalidateWindowData(WC_BUILD_VEHICLE, st->airport.hangar->index);

		/* Always update the noise, so there will be no need to recalculate when option toggles. */
		UpdateNoiseForTowns(pre_town, post_town, pre_noise, post_noise);

		UpdateAircraftOnUpdatedAirport(st);

		if (_settings_game.economy.station_noise_level) {
			SetWindowDirty(WC_TOWN_VIEW, st->town->index);
		}
	}

	return cost;
}

CommandCost RemoveAirportTiles(DoCommandFlag flags, TileIndex start_tile, TileIndex end_tile, AirType air_type)
{
	if (!IsValidTile(end_tile)) return CMD_ERROR;

	if (_current_company < MAX_COMPANIES && !ValParamAirType(air_type)) return_cmd_error(STR_ERROR_AIRPORT_INCORRECT_AIRTYPE);

	TileArea ta(start_tile, end_tile);
	std::vector<Station *> affected_stations;

	CommandCost cost(EXPENSES_CONSTRUCTION);
	bool any_change = false;

	for (TileIndex tile : ta) {
		if (!IsAirportTile(tile)) continue;
		if (air_type != GetAirType(tile)) continue;
		if (MayHaveAirTracks(tile) && (HasAirportTrackReserved(tile) || HasReservationsOnNeighbourTiles(tile))) continue;

		if (_current_company != OWNER_WATER) {
			CommandCost ret = CheckTileOwnership(tile);
			if (ret.Failed()) continue;
		}

		if (IsStandardHangarTile(tile)) {
			CommandCost ret = EnsureFreeHangar(tile);
			if (ret.Failed()) continue;
		}

		/* Check aircraft in airport. */
		Station *st = Station::GetByTile(tile);
		if (std::find(affected_stations.begin(), affected_stations.end(), st) == affected_stations.end()) {
			assert(st != nullptr);

			if (flags & DC_EXEC) {
				/* Remove airport noise in closest town. */
				uint dist;
				BitmapTileArea bta;
				bta.Initialize(st->airport);
				for (TileIndex t : st->airport) {
					if (st->TileBelongsToAirport(t)) bta.SetTile(t);
				}
				Town *nearest = AirportGetNearestTown(bta, dist);
				uint8_t noise_level = CalculateAirportNoiseLevel(st->airport);
				nearest->noise_reached -= GetAirportNoiseLevelForDistance(noise_level, dist);

				affected_stations.emplace_back(st);
			}
		}

		if (IsRunway(tile)) {
			if (_current_company < MAX_COMPANIES && (flags & DC_FORCE_CLEAR_TILE) == 0) return_cmd_error(STR_ERROR_AIRPORT_REMOVE_RUNWAYS_FIRST);
			if (GetReservationAsRunway(tile)) {
				// in fact, if water flooding, check for landing aircraft and crash it
				return CMD_ERROR;
			}
		}

		cost.AddCost(AirClearCost(air_type));
		any_change = true;

		if (!IsSimpleTrack(tile)) cost.AddCost(AirClearCost(air_type));

		if (flags & DC_EXEC) {
			WaterClass wc = HasTileWaterClass(tile) ? GetWaterClass(tile) : WATER_CLASS_INVALID;
			DoClearSquare(tile);
			/* Maybe change to water */
			if (wc != WATER_CLASS_INVALID) {
				Owner o = (wc == WATER_CLASS_CANAL) ? st->owner : OWNER_WATER;
				MakeWater(tile, o, wc, Random());
			}

			Company *c = Company::Get(st->owner);
			c->infrastructure.air[air_type]--;
			c->infrastructure.station--;
			DeleteNewGRFInspectWindow(GSF_AIRPORTTILES, tile.base());
			DeleteNewGRFInspectWindow(GSF_AIRTYPES, tile.base());

			st->rect.AfterRemoveTile(st, tile);
			MarkTileDirtyByTile(tile);
		}
	}

	if (flags & DC_EXEC) {
		/* Do all station specific functions here. */
		for (Station *st : affected_stations) {
			TileArea temp(ta.tile, ta.w, ta.h);
			st->airport.Clear();
			for (TileIndex tile : temp) {
				if (IsAirportTile(tile) && st->index == GetStationIndex(tile)) st->airport.Add(tile);
			}

			st->UpdateAirportDataStructure();
			if (st->airport.tile == INVALID_TILE) {
				st->facilities &= ~FACIL_AIRPORT;
				DeleteNewGRFInspectWindow(GSF_AIRPORTS, st->index);
			} else {
				uint dist;
				BitmapTileArea bta;
				bta.Initialize(st->airport);
				for (TileIndex t : st->airport) {
					if (st->TileBelongsToAirport(t)) bta.SetTile(t);
				}
				Town *nearest = AirportGetNearestTown(bta, dist);
				uint8_t noise_level = CalculateAirportNoiseLevel(st->airport);
				nearest->noise_reached += GetAirportNoiseLevelForDistance(noise_level, dist);
			}
			st->AfterStationTileSetChange(true, STATION_AIRPORT);
			st->MarkTilesDirty(false);
			UpdateAircraftOnUpdatedAirport(st);
		}

	}

	if (!any_change) return CMD_ERROR;

	return cost;
}

/**
 * Clear an airport tile, removing also its runways if any.
 * @param tile The tile to be cleared.
 * @param flags Command flags
 * @return The cost in case of success, or an error code if it failed.
 */
CommandCost ClearAirportTile(TileIndex tile, DoCommandFlag flags)
{
	assert(IsAirportTile(tile));
	CommandCost cost(EXPENSES_CONSTRUCTION);

	if (IsRunway(tile)) {
		TileIndex start_tile = tile;
		TileIndex end_tile = tile;
		DiagDirection dir = INVALID_DIAGDIR;

		if (IsPlainRunway(tile)) {
			Direction direction = GetPlainRunwayDirections(tile);
			if (!IsDiagonalDirection(direction)) {
				dir = DirToDiagDir((Direction)((direction - 1) & (DIR_END - 1)));
				end_tile = GetRunwayExtreme(tile, dir);
				start_tile = GetRunwayExtreme(tile, ReverseDiagDir(dir));
				cost.AddCost(RemoveRunway(flags, start_tile, end_tile));
				direction++;
			}
			assert(IsDiagonalDirection(direction));
			dir = DirToDiagDir(direction);
		} else {
			assert(IsRunwayExtreme(tile));
			dir = GetRunwayExtremeDirection(tile);
		}
		end_tile = GetRunwayExtreme(tile, dir);
		start_tile = GetRunwayExtreme(tile, ReverseDiagDir(dir));
		cost.AddCost(RemoveRunway(flags, start_tile, end_tile));
	}

	cost.AddCost(RemoveAirportTiles(flags | DC_FORCE_CLEAR_TILE, tile, tile, GetAirType(tile)));
	return cost;
}

TileIndex GetAnAirportTile(Station* st)
{
	if (st == nullptr || st->airport.tile == INVALID_TILE) return INVALID_TILE;

	for (TileIndex tile : st->airport) {
		if (st->TileBelongsToAirport(tile)) return tile;
	}

	NOT_REACHED();
}

/**
 * Checks if an airport can be built at the given area.
 * @param tile_area Area to check.
 * @param flags Operation to perform.
 * @param station StationID to be queried and returned if available.
 * @param allow_extending Whether to allow already airport tiles in the area.
 * @return The cost in case of success, or an error code if it failed.
 */
static CommandCost CheckFlatLandAirport(BitmapTileArea tile_area, DoCommandFlag flags, StationID &station, bool build_on_water, bool allow_extending)
{
	CommandCost cost(EXPENSES_CONSTRUCTION);
	int allowed_z = -1;

	/* Distant join */
	Station *st = Station::GetIfValid(station);

	if (st != nullptr && (st->facilities & FACIL_AIRPORT) != FACIL_NONE) {
		TileIndex tile = GetAnAirportTile(st);
		auto [tileh, z] = GetTileSlopeZ(tile);
		allowed_z = z + GetSlopeMaxZ(tileh);
	}

	for (TileIndex tile : tile_area) {
		if (!tile_area.HasTile(tile)) continue;

		/* if station is set, then we have special handling to allow building on top of already existing stations.
		 * so station points to INVALID_STATION if we can build on any station.
		 * Or it points to a station if we're only allowed to build on exactly that station. */
		if (allow_extending && IsAirportTile(tile)) {
			StationID st_id = GetStationIndex(tile);
			if (station == INVALID_STATION) {
				station = st_id;
			} else if (station != st_id) {
				return_cmd_error(STR_ERROR_ADJOINS_MORE_THAN_ONE_EXISTING);
			}
			continue;
		}

		CommandCost ret = CheckBuildableTile(tile, 0, allowed_z, false, true);
		if (ret.Failed()) return ret;

		if (build_on_water) {
			if (!IsWaterTile(tile) || !IsTileFlat(tile)) return_cmd_error(STR_ERROR_AIRPORT_PLAIN_WATER);
		} else {
			if (IsTileType(tile, MP_WATER)) {
				Slope tileh = GetTileSlope(tile);
				if (!IsSlopeWithOneCornerRaised(tileh)) return_cmd_error(STR_ERROR_CAN_T_BUILD_ON_WATER);
				cost.AddCost(-_price[PR_CLEAR_WATER]);
				cost.AddCost(_price[PR_CLEAR_ROUGH]);
			}
		}
		if (!build_on_water) cost.AddCost(Command<CMD_LANDSCAPE_CLEAR>::Do(flags, tile));
		if (cost.Failed()) return cost;
	}

	return cost;
}

/**
 * Add/remove tiles for an airport.
 * @param flags operation to perform
 * @param start_tile start tile of drag
 * @param end_tile end tile of drag
 * @param adding whether to add or remove tiles
 * @param at air type
 * @param station_to_join StationID where to apply the command (NEW_STATION for a new station).
 * @param adjacent allow airports directly adjacent to other airports.
 * @return the cost of this operation or an error
 */
CommandCost CmdAddRemoveAirportTiles(DoCommandFlag flags, TileIndex start_tile, TileIndex end_tile, bool adding, AirType at, StationID station_to_join, bool adjacent)
{
	CommandCost ret = CheckSettingBuildByTile();
	if (ret.Failed()) return ret;

	if (!adding) return RemoveAirportTiles(flags, start_tile, end_tile, at);

	/* Does the authority allow this? */
	ret = CheckIfAuthorityAllowsNewStation(start_tile, flags);
	if (ret.Failed()) return ret;

	/* Check air type. */
	if (!ValParamAirType(at)) return_cmd_error(STR_ERROR_AIRPORT_INCORRECT_AIRTYPE);
	const AirTypeInfo *ati = GetAirTypeInfo(at);

	TileArea new_location(start_tile, end_tile);
	BitmapTileArea bta;
	bta.Initialize(new_location);
	for (TileIndex t : new_location) bta.SetTile(t);

	if (new_location.w > _settings_game.station.station_spread || new_location.h > _settings_game.station.station_spread) return CMD_ERROR;

	bool reuse = (station_to_join != NEW_STATION);
	if (!reuse) station_to_join = INVALID_STATION;
	bool distant_join = (station_to_join != INVALID_STATION);

	if (distant_join && (!_settings_game.station.distant_join_stations || !Station::IsValidID(station_to_join))) return CMD_ERROR;

	Station *st = nullptr;
	if (Station::IsValidID(station_to_join)) {
		st = Station::Get(station_to_join);
		if ((st->facilities & FACIL_AIRPORT) && st->airport.air_type != at)
			return_cmd_error(STR_ERROR_AIRPORT_INCORRECT_AIRTYPE);
	}

	/* Make sure the area below consists of clear tiles. */
	StationID est = st == nullptr ? INVALID_STATION : st->index;
	/* Clear the land below the station. */
	CommandCost cost = CheckFlatLandAirport(bta, flags, est, ati->build_on_water, true);
	if (cost.Failed()) return cost;

	st = nullptr;
	ret = FindJoiningAirport(est, station_to_join, adjacent, new_location, &st);
	if (ret.Failed()) return ret;

	if (st != nullptr && st->airport.tile != INVALID_TILE && st->airport.air_type != at) return_cmd_error(STR_ERROR_AIRPORT_INCORRECT_AIRTYPE);

	Town *pre_town = nullptr;
	Town *post_town = nullptr;
	uint pre_noise;
	uint post_noise = (st == nullptr || (st->facilities & FACIL_AIRPORT) == FACIL_NONE) ? GetAirTypeInfo(at)->base_noise_level : 0;
	ret = CheckTownAuthorityForAirports(new_location.tile, st, bta, &pre_town, &post_town, pre_noise, post_noise);
	if (ret.Failed()) return ret;

	ret = BuildStationPart(&st, flags, reuse, new_location, STATIONNAMING_AIRPORT);
	if (ret.Failed()) return ret;

	TileIndex airport_tile = GetAnAirportTile(st);
	int z = -1;
	if (airport_tile != INVALID_TILE) {
		auto [tileh, z] = GetTileSlopeZ(airport_tile);
		z = z + GetSlopeMaxZ(tileh);
	}

	Company *c = Company::GetIfValid(_current_company);

	bool tile_changed = false;
	for (TileIndex tile : new_location) {
		if (IsAirportTile(tile)) {
			assert(GetStationIndex(tile) == st->index);
			continue;
		}
		ret = CheckBuildableTile(tile, 0, z, false, true);
		if (ret.Failed()) return_cmd_error(STR_ERROR_AIRPORT_NOT_SAME_LEVEL);

		cost.AddCost(_price[PR_BUILD_STATION_AIRPORT] * ati->cost_multiplier);
		tile_changed = true;

		if (flags & DC_EXEC) {
			st->airport.Add(tile);

			/* Initialize an empty station. */
			st->AddFacility(FACIL_AIRPORT, tile);

			st->rect.BeforeAddTile(tile, StationRect::ADD_TRY);
			WaterClass wc = WATER_CLASS_INVALID;
			if (ati->build_on_water && HasTileWaterClass(tile)) wc = GetWaterClass(tile);

			MakeAirport(tile, st->owner, st->index, 0, wc);
			SetAirType(tile, at);
			SetAirportTileType(tile, ATT_SIMPLE_TRACK);
			SetAirGfxType(tile, true);

			c->infrastructure.air[at]++;
			c->infrastructure.station++;
			DirtyCompanyInfrastructureWindows(c->index);
			MarkTileDirtyByTile(tile);
		}
	}

	if (!tile_changed) return CMD_ERROR;

	if (flags & DC_EXEC) {
		assert(st != nullptr);
		st->UpdateAirportDataStructure();
		st->AfterStationTileSetChange(true, STATION_AIRPORT);

		UpdateNoiseForTowns(pre_town, post_town, pre_noise, post_noise);
		UpdateAircraftOnUpdatedAirport(st);
	}

	return cost;
}

/**
 * Place an Airport.
 * @param flags operation to perform
 * @param tile tile where airport will be built
 * @param airport_type airport type, @see airport.h
 * @param layout airport layout
 * @param air_type airport airtype (if modify airports is enabled)
 * @param rotation rotation for the airport to be built
 * @param station_to_join station ID to join (NEW_STATION if build new one)
 * @param allow_adjacent allow airports directly adjacent to other airports.
 * @return the cost of this operation or an error
 */
CommandCost CmdBuildAirport(DoCommandFlag flags, TileIndex tile, uint8_t airport_type, uint8_t layout, AirType air_type, DiagDirection rotation, StationID station_to_join, bool allow_adjacent)
{
	bool reuse = (station_to_join != NEW_STATION);
	if (!reuse) station_to_join = INVALID_STATION;
	bool distant_join = (station_to_join != INVALID_STATION);

	if (distant_join && (!_settings_game.station.distant_join_stations || !Station::IsValidID(station_to_join))) return CMD_ERROR;

	/* By now, do not accept newgrf airports. */
	if (airport_type >= NEW_AIRPORT_OFFSET) return CMD_ERROR;

	CommandCost ret = CheckIfAuthorityAllowsNewStation(tile, flags);
	if (ret.Failed()) return ret;

	/* Check if a valid, buildable airport was chosen for construction */
	const AirportSpec *as = AirportSpec::Get(airport_type);
	if (air_type == INVALID_AIRTYPE) air_type = as->airtype;

	if (_settings_game.station.allow_modify_airports &&
			as->min_runway_length > 0 &&
			as->min_runway_length < GetAirTypeInfo(air_type)->min_runway_length)
		return_cmd_error(STR_ERROR_AIRPORT_RUNWAY_TOO_SHORT);

	if (!ValParamAirType(air_type)) return_cmd_error(STR_ERROR_AIRPORT_INCORRECT_AIRTYPE);
	const AirTypeInfo *ati = GetAirTypeInfo(air_type);

	if (as->has_hangar && !Depot::CanAllocateItem()) return CMD_ERROR;
	if (!as->IsAvailable()) return CMD_ERROR;

	uint16_t w = as->size_x;
	uint16_t h = as->size_y;
	if (rotation % 2 != 0) Swap(w, h);

	TileArea airport_area = TileArea(tile, w, h);

	/* Check we are within map bounds. */
	if (TileX(tile) + w >= Map::SizeX() || TileY(tile) + h >= Map::SizeY()) return CMD_ERROR;

	if (w > _settings_game.station.station_spread || h > _settings_game.station.station_spread) {
		return_cmd_error(STR_ERROR_STATION_TOO_SPREAD_OUT);
	}

	BitmapTileArea new_airport_tiles; // New airport tiles to be built.
	new_airport_tiles.Initialize(airport_area);
	CommandCost cost = AddAirportTileTableToBitmapTileArea(as->layouts[layout], &new_airport_tiles, rotation, ati->cost_multiplier);

	Station *st = nullptr;
	ret = FindJoiningAirport(INVALID_STATION, station_to_join, allow_adjacent, airport_area, &st);
	if (ret.Failed()) return ret;

	/* Distant join */
	if (st == nullptr && distant_join) st = Station::GetIfValid(station_to_join);

	cost.AddCost(CheckFlatLandAirport(new_airport_tiles, flags, station_to_join, ati->build_on_water, false));
	if (cost.Failed()) return cost;

	Town *pre_town = nullptr;
	Town *post_town = nullptr;
	uint pre_noise;
	uint post_noise = as->GetAirportNoise(air_type);
	if (st != nullptr && (st->facilities & FACIL_AIRPORT) != FACIL_NONE) post_noise -= GetAirTypeInfo(st->airport.air_type)->base_noise_level;

	ret = CheckTownAuthorityForAirports(tile, st, new_airport_tiles, &pre_town, &post_town, pre_noise, post_noise);
	if (ret.Failed()) return ret;

	if (st != nullptr && (st->facilities & FACIL_AIRPORT) && !_settings_game.station.allow_modify_airports) {
		return_cmd_error(STR_ERROR_TOO_CLOSE_TO_ANOTHER_AIRPORT);
	}

	uint total_runways = as->num_runways;
	if (st != nullptr && (st->facilities & FACIL_AIRPORT)) total_runways += (uint)st->airport.runways.size();
	if (total_runways > GetAirTypeInfo(air_type)->max_num_runways) return_cmd_error(STR_ERROR_AIRPORT_TOO_MUCH_RUNWAYS);

	ret = BuildStationPart(&st, flags, reuse, airport_area,
			as->has_heliport ? STATIONNAMING_HELIPORT : STATIONNAMING_AIRPORT);
	if (ret.Failed()) return ret;

	if (flags & DC_EXEC) {
		/* Always update the noise, so there will be no need to recalculate when option toggles. */
		UpdateNoiseForTowns(pre_town, post_town, pre_noise, post_noise);

		st->AddFacility(FACIL_AIRPORT, tile);
		st->airport.type = airport_type;
		st->airport.layout = layout;

		st->rect.BeforeAddRect(tile, w, h, StationRect::ADD_TRY);

		uint tiles = 0;
		for (TileIndex t : new_airport_tiles) {
			uint pos = RotatedAirportSpecPosition(t, new_airport_tiles, rotation);
			if (as->layouts[layout].tiles[pos].type == ATT_INVALID) continue; // does not belong to new airport tiles.
			tiles++;
			WaterClass wc = HasTileWaterClass(t) ? GetWaterClass(t) : WATER_CLASS_INVALID;
			MakeAirport(t, st->owner, st->index, 0, wc);
			SetStationTileRandomBits(t, GB(Random(), 0, 4));
			st->airport.Add(t);
			MarkTileDirtyByTile(t);
		}

		st->LoadAirportTilesFromSpec(airport_area, rotation, air_type);

		/* Replace all hangars with hangars the human user can build. */
		bool allow_standard_hangars = HasBit(_settings_game.depot.hangar_types, 0);
		bool allow_extended_hangars = HasBit(_settings_game.depot.hangar_types, 1);
		if (Company::IsValidHumanID(_current_company) && (!allow_standard_hangars || !allow_extended_hangars)) {
			for (TileIndex t : new_airport_tiles) {
				uint pos = RotatedAirportSpecPosition(t, new_airport_tiles, rotation);
				if (as->layouts[layout].tiles[pos].type == ATT_INVALID) continue; // does not belong to new airport tiles.
				assert(IsAirportTileOfStation(t, st->index));

				/* Should we allow standard and extended hangars? */
				if (!IsHangar(t)) continue;
				if (IsExtendedHangar(t)) {
					if (!allow_extended_hangars) SetExtendedHangar(t, false);
				} else {
					if (!allow_standard_hangars) SetExtendedHangar(t, true);
				}
			}
		}

		/* Set animated tiles. */
		for (TileIndex t : new_airport_tiles) {
			if (!st->TileBelongsToAirport(t)) continue;
			if (AirportTileSpec::GetByTile(t)->animation.status != ANIM_STATUS_NO_ANIMATION) AddAnimatedTile(t);
		}

		/* Only call the animation trigger after all tiles have been built */
		for (TileIndex t : new_airport_tiles) {
			if (!st->TileBelongsToAirport(t)) continue;
			AirportTileAnimationTrigger(st, t, AAT_BUILT);
		}

		Company *c = Company::Get(st->owner);
		c->infrastructure.air[air_type] += tiles;
		c->infrastructure.station += tiles;

		st->AfterStationTileSetChange(true, STATION_AIRPORT);
		InvalidateWindowData(WC_STATION_VIEW, st->index, -1);

		UpdateAircraftOnUpdatedAirport(st);
	}

	return cost;
}

/**
 * Remove an airport
 * @param tile TileIndex been queried
 * @param flags operation to perform
 * @return cost or failure of operation
 */
CommandCost RemoveAirport(TileIndex tile, DoCommandFlag flags)
{
	Station *st = Station::GetByTile(tile);

	CommandCost ret = AircraftInAirport(st);
	if (ret.Failed()) return ret;

	if (_current_company != OWNER_WATER) {
		ret = CheckOwnership(st->owner);
		if (ret.Failed()) return ret;
	}

	CommandCost cost(EXPENSES_CONSTRUCTION);

	Town *nearest;
	if (flags & DC_EXEC) {
		if (st->airport.HasHangar()) {
			CloseWindowById(WC_VEHICLE_DEPOT, st->airport.hangar->index);
			OrderBackup::Reset(st->airport.hangar->index, false);
		}

		/* The noise level is the noise from the airport and reduce it to account for the distance to the town center.
		 * And as for construction, always remove it, even if the setting is not set, in order to avoid the
		 * need of recalculation */
		uint dist;
		BitmapTileArea bta;
		bta.Initialize(st->airport);
		for (TileIndex t : st->airport) {
			if (st->TileBelongsToAirport(t)) bta.SetTile(t);
		}
		nearest = AirportGetNearestTown(bta, dist);
		uint8_t noise_level = CalculateAirportNoiseLevel(st->airport);
		nearest->noise_reached -= GetAirportNoiseLevelForDistance(noise_level, dist);

		if (_settings_game.economy.station_noise_level) {
			SetWindowDirty(WC_TOWN_VIEW, nearest->index);
		}
	}


	uint tiles = 0;
	for (TileIndex tile_cur : st->airport) {
		if (!st->TileBelongsToAirport(tile_cur)) continue;

		tiles++;

		if (flags & DC_EXEC) {
			Company *c = Company::Get(st->owner);
			c->infrastructure.air[st->airport.air_type]--;
			c->infrastructure.station--;
			DeleteAnimatedTile(tile_cur);
			DoClearSquare(tile_cur);
			DeleteNewGRFInspectWindow(GSF_AIRPORTTILES, tile_cur.base());
			DeleteNewGRFInspectWindow(GSF_AIRTYPES, tile_cur.base());
		}
	}

	const AirTypeInfo *ati = GetAirTypeInfo(st->airport.air_type);
	cost.AddCost(_price[PR_CLEAR_STATION_AIRPORT] * ati->cost_multiplier * tiles);

	if (flags & DC_EXEC) {
		/* Clear the persistent storage. */
		delete st->airport.psa;

		st->rect.AfterRemoveRect(st, st->airport);

		st->UpdateAirportDataStructure();
		st->airport.Clear();
		st->facilities &= ~FACIL_AIRPORT;

		InvalidateWindowData(WC_STATION_VIEW, st->index, -1);

		st->AfterStationTileSetChange(false, STATION_AIRPORT);

		DeleteNewGRFInspectWindow(GSF_AIRPORTS, st->index);

		UpdateAircraftOnUpdatedAirport(st);
	}

	return cost;
}

void BuildBuiltInHeliport(Tile tile)
{
	if (!Station::CanAllocateItem()) {
		Debug(misc, 0, "Can't allocate built in station for industry at 0x{}. Built in station won't be built.", static_cast<uint32_t>(tile));
		return;
	}

	Station *st = new Station(tile);
	_station_kdtree.Insert(st->index);
	st->town = ClosestTownFromTile(tile, UINT_MAX);

	st->string_id = GenerateStationName(st, tile, STATIONNAMING_OILRIG);

	assert(IsTileType(tile, MP_INDUSTRY));
	/* Mark industry as associated both ways */
	st->industry = Industry::GetByTile(tile);
	st->industry->neutral_station = st;
	DeleteAnimatedTile(tile);
	MakeStation(tile, OWNER_NONE, st->index, STATION_AIRPORT, 0, GetWaterClass(tile));

	const AirportSpec *as = AirportSpec::Get(AT_OILRIG);
	const AirportTileTable *tile_desc = &as->layouts[0].tiles[0];
	tile.m4() = 0;
	tile.m5() = 0;
	SetAirType(tile, as->airtype);
	SetAirportTileType(tile, tile_desc->type);
	SetAirportTileTracks(tile, tile_desc->trackbits);
	SetApronType(tile, tile_desc->apron_type);
	st->airport.flags = AF_NONE;

	st->owner = OWNER_NONE;
	st->airport.type = AT_OILRIG;
	st->airport.air_type = as->airtype;
	st->airport.Add(tile);
	st->ship_station.Add(tile);
	st->facilities = FACIL_AIRPORT | FACIL_DOCK;
	st->build_date = TimerGameCalendar::date;
	UpdateStationDockingTiles(st);

	st->rect.BeforeAddTile(tile, StationRect::ADD_FORCE);

	st->UpdateAirportDataStructure();
	st->UpdateVirtCoord();

	/* An industry tile has now been replaced with a station tile, this may change the overlap between station catchments and industry tiles.
	 * Recalculate the station catchment for all stations currently in the industry's nearby list.
	 * Clear the industry's station nearby list first because Station::RecomputeCatchment cannot remove nearby industries in this case. */
	if (_settings_game.station.serve_neutral_industries) {
		StationList nearby = std::move(st->industry->stations_near);
		st->industry->stations_near.clear();
		for (Station *near : nearby) {
			near->RecomputeCatchment(true);
			UpdateStationAcceptance(near, true);
		}
	}

	st->RecomputeCatchment();
	UpdateStationAcceptance(st, false);
}

void DeleteOldBuiltInHeliport(TileIndex tile)
{
	Station *st = Station::GetByTile(tile);

	MakeWaterKeepingClass(tile, OWNER_NONE);

	/* The oil rig station is not supposed to be shared with anything else */
	assert(st->facilities == (FACIL_AIRPORT | FACIL_DOCK) && st->airport.type == AT_OILRIG);
	if (st->industry != nullptr && st->industry->neutral_station == st) {
		/* Don't leave dangling neutral station pointer */
		st->industry->neutral_station = nullptr;
	}

	delete st;
}

void DeleteBuiltInHeliport(TileIndex tile)
{
	assert(IsBuiltInHeliportTile(tile));
	Station *st = Station::GetByTile(tile);

	bool helicopter_present = HasAirportTrackReserved(tile);
	MakeWaterKeepingClass(tile, OWNER_NONE);

	/* The oil rig station is not supposed to be shared with anything else */
	assert(st->facilities == (FACIL_AIRPORT | FACIL_DOCK) && st->airport.type == AT_OILRIG);
	if (st->industry != nullptr && st->industry->neutral_station == st) {
		/* Don't leave dangling neutral station pointer */
		st->industry->neutral_station = nullptr;
	}

	st->airport.tile = INVALID_TILE;
	st->airport.air_type = INVALID_AIRTYPE;
	st->facilities = FACIL_NONE;

	if (helicopter_present) {
		for (Aircraft *a : Aircraft::Iterate()) {
			if (!a->IsNormalAircraft()) continue;
			if (!a->IsHelicopter()) continue;
			if (a->tile != tile) continue;
			if (a->state == AS_BUILTIN_HELIPORT ||
					a->state == AS_START_TAKEOFF ||
					a->state == AS_LANDED ||
					a->state == AS_FLYING_HELICOPTER_TAKEOFF ||
					a->state == AS_FLYING_HELICOPTER_LANDING ||
					a->state == AS_ON_HOLD_APPROACHING) {
				a->state = AS_FLYING;
				ProcessOrders(a);
			}
		}
	}

	UpdateAircraftOnUpdatedAirport(st);
	delete st;
}

/**
 * Open/close an airport to incoming aircraft.
 * @param flags Operation to perform.
 * @param station_id Station ID of the airport.
 * @return the cost of this operation or an error
 */
CommandCost CmdOpenCloseAirport(DoCommandFlag flags, StationID station_id)
{
	if (!Station::IsValidID(station_id)) return CMD_ERROR;
	Station *st = Station::Get(station_id);

	if (!(st->facilities & FACIL_AIRPORT) || st->owner == OWNER_NONE) return CMD_ERROR;

	CommandCost ret = CheckOwnership(st->owner);
	if (ret.Failed()) return ret;

	if (flags & DC_EXEC) {
		st->airport.flags ^= AF_CLOSED_MANUAL;
		SetWindowWidgetDirty(WC_STATION_VIEW, st->index, WID_SV_CLOSE_AIRPORT);
		UpdateAircraftOnUpdatedAirport(st);
	}
	return CommandCost();
}
